"""
    课程1：python基础
    1. Python简介
        执行过程：源代码-"编译"->字节码-解释->机器码
                |    第一次     |
            备注：只有通过导入的模块才会编译
    2. 数据基本运算
        1) pycharm快捷键(百度搜索)
        2) python内存自动管理机制
            -- 引用计数：每个对象记录被变量绑定(引用)的数量,当为0时被"销毁"。
                   缺点：循环引用
            -- 标记清除：对内存进行全盘扫描,标记需要被清除的对象.
                   缺点：由于内存过大，所以效率低.
            -- 分代回收：
                a. 创建新对象在"年轻代"开辟空间.
                b. 当某一代内存不足时,进行标记清除,将可用对象升代.
            价值 --内存优化：
                a. 尽少产生垃圾
                b. 对象池:每次创建对象时,先判断池中是否存在可用对象,如果存在则返回地址,如果不在则创建。
                c. 控制管理机制(设置每代内存大小,开始回收....)
    3. 容器
        str字符串：存储字符编码值,不可变,序列
        list列表：存储变量,可变,序列
        tuple元组：存储变量,不可变,序列
        dict字典:存储键值对,可变,散列
        set集合：存储键,可变,散列
        可变：预留空间
        不可变：按需分配
        序列：有序(索引/切片),空间连续(节省内存)
        散列：无序,空间不连续(占用内存过度,查找快)
        容器转换
            容器名称(可迭代对象)
            -- 惰性操作(节省内存) 转换为 立即操作(定位灵活)
            容器名称(生成器)
    4. 函数
        1)可变与不可变类型对象传参
            可变：列表、字典、集合、自定义类(老婆类)
            不可变：数值类型、bool、字符串、元组
        2)参数
            实参：将数据传递给形参
                a.位置：按照顺序
                    函数名(数据1,数据2)
                    b.序列：拆
                        函数名(*序列)
                c.关键字：按照名称
                    函数名(形参名1 = 数据1,形参名2 = 数据2)
                    d.字典：拆
                        函数名(**字典)

            形参：约束实参种类
                a.默认:可选(无论位置实参还是关键字实参)
                    def 函数名(形参名1 = 默认值,形参名2 = 默认值)
                b.位置:必选(无论位置实参还是关键字实参)
                    def 函数名(形参名1,形参名2)
                        c.元组：将位置实参合并为元组
                          def 函数名(*args)
                d.关键字:必须关键字实参
                    def 函数名(*,形参名1,形参名2)
                    def 函数名(*args,形参名1,形参名2)
                        e.字典：将关键字实参合并为字典
                          def 函数名(**kwargs)

"""
a = 10  # 整数10的引用计数为1
b = a  # 整数10的引用计数为2
a = 20  # 整数10的引用计数为1
del b  # 整数10的引用计数为0
# 缺点：循环引用
list01 = []
list02 = []
list01.append(list02)
list02.append(list01)
del list01, list02

data01 = True
data02 = True
print(id(data01), id(data02))

data03 = []
data04 = []
print(id(data03), id(data04))

# list_result =[]
# for i in range(100):
#     list_result.append(str(i))
#     # str_result += str(i)
# print("".join(list_result))

name01 = " 悟空"
name02 = "八戒"
name03 = name01 + name02
name04 = name01.lstrip()
print(id(name04), id(name01))

# 容器拼接
list01 = [10]
list01 += [20]

dict01 = {"a": 1}
dict01.update({"b": 2})
print(dict01)

# 不可变类型的数据传参时，函数内部不会改变原数据的值。
# 可变类型的数据传参时，函数内部可以改变原数据
class Wife:
    pass

def func01(p1 = None,p2 = None):
    p1.name = "双儿"# 可以修改
    tuple01 = (20,)# 不可以修改

w01 = Wife()
tuple01 = (10,)
func01(w01,tuple01)
func01(p2 = tuple01)
print(w01.__dict__)# {'name': '双儿'}  所以变化
print(tuple01)#(10,)                  所以不变

# 结论：传入可变对象、修改可变对象、无需使用return返回结果
def func02(p1):
    p1 = Wife()
    p1.name = "双双"# 可以修改
    return p1
w01 = func02(w01)
print(w01.__dict__)
